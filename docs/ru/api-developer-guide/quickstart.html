<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>quickstart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Быстрый старт</h1>
<p>Здесь детально описан процесс создания простого приложения под Android с возможностями голосового управления с помощью API <em>Ассистента на русском</em>.</p>
<h2>Что необходимо уметь</h2>
<p>Для того, чтобы реализовать все нижеописанное, вам потребуются знания и навыки работы с языком программирования Java, использования <a href="http://developer.android.com/develop/index.html">Android SDK</a>, и какая-либо IDE для разработки приложений под Android.</p>
<h2>Что будет реализовано в этом примере</h2>
<p>В этом примере мы реализуем простое приложение, умеющее знакомиться с пользователем, запоминать его имя и здороваться с ним каждый раз, обращаясь к нему по ранее сохранённому имени.</p>
<p>Эта функциональность может быть реализована в виде отдельного приложения под Android, либо встроена в уже имеющееся у вас приложение.</p>
<h2>Создание нового проекта</h2>
<p>В используемой IDE создайте новый проект приложения Android, либо используйте уже имеющийся. Нам потребуется создать несколько файлов исходных кодов и файлов с описанием грамматик запросов.</p>
<p>Мы предлагаем использовать последнюю версию <a href="http://developer.android.com/sdk/installing/studio.html">Android Studio</a> и <a href="http://www.gradle.org/">Gradle</a>. Для нового проекта вам потребуется прописать в файле <code>build.gradle</code> вашего проекта следующее</p>
<pre><code>repositories {
    maven {
        url 'http://voiceassistant.mobi/m2/repository'
    }
}

dependencies {
    compile 'mobi.voiceassistant:client:0.1.0-SNAPSHOT'
    compile 'mobi.voiceassistant:base:0.1.0-SNAPSHOT'
}
</code></pre>

<p>Это настройка зависимостей от двух библиотек ассистента, которые будут использованы вашим приложением.</p>
<p><em>Обратите внимание на постфикс SNAPSHOT - он указывает, что данная версия библиотеки не финальная. В ближайшем будущем она будет часто обновляться</em></p>
<h3>Создание грамматики запросов</h3>
<p>Создайте файл hello.xml в директории xml вашего проекта. В нём мы опишем <a href="grammarsyntax.html">грамматику запросов</a>, позволяющую преобразовать речь пользователя в команды вашему приложению.</p>
<blockquote>
<h4>Как речь превращается в команды</h4>
<p><em>Ассистент на русском</em> использует технологию распознавания речи, которая преобразует речь пользователя в текст. Из этого текста ассистенту необходимо &quot;понять&quot;, к какому приложению относится этот текст, какая команда и в каком контексте должна быть выполнена, и выделить из этого текста данные, необходимые для выполнения команды.</p>
<p>Для этого в грамматике запросов необходимо написать <a href="patternsyntax.html">паттерны</a>, которые опишут, на какие фразы пользователя нужно реагировать вашей программе, и какие данные из этой фразы необходимо получить для выполнения тех или иных команд.</p>
</blockquote>
<p>В файле hello.xml напишите следующее</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;module xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;command android:id=&quot;@+id/cmd_hello&quot;&gt;
        &lt;pattern value=&quot;привет* *&quot;/&gt;
    &lt;/command&gt;

&lt;/module&gt;
</code></pre>

<p>Здесь мы пока описали только одну команду с идентификатором <code>cmd_hello</code> и одним единственным паттерном. Этот паттерн будет срабатывать на фразах типа &quot;Привет&quot;, &quot;Приветы&quot;, &quot;Привет как дела&quot; и т.п., начинающиеся с формы слова <em>привет</em> с любым окончанием и заканчивающиеся любым количеством любых других слов.</p>
<h3>Создание агента</h3>
<p><a href="agents.html">Агент</a> - это программный интерфейс между ассистентом и бизнес-логикой вашего приложения. По сути это надстройка над стандартными Android-сервисами, содержащая специальные методы по управлению диалогом с пользователем.</p>
<p>Для создания агента нам потребуется написать класс, реализующий абстракцию <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/client/AssistantAgent.html"><code>AssistantAgent</code></a></p>
<pre><code>public class HelloAgent extends AssistantAgent {
    @Override
    protected void onCommand(Request request) {
    }
}
</code></pre>

<p>Каждый агент обязан переопределить по крайней мере один метод - <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Agent.html#onCommand(mobi.voiceassistant.base.Request)"><code>onCommand</code></a>, который является точкой входа для ассистента. В этот метод ассистент передаёт специальный контейнер данных <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html"><code>Request</code></a>, содержащий всё необходимое для обработки запроса от пользователя.</p>
<pre><code>@Override
protected void onCommand(Request request) {
    switch (request.getDispatchId()) {
        case R.id.cmd_hello:
            onHello(request);
            break;
    }
}

private void onHello(Request request) {
}
</code></pre>

<p>Здесь мы диспетчеризуем нашу пока единственную команду с идентификатором <code>cmd_hello</code> в метод <code>onHello</code>, где впоследствии реализуем логику приветствия и знакомства с пользователем. Для этого мы пользуемся методом <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html#getDispatchId()"><code>getDispatchId</code></a> класса <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html"><code>Request</code></a>, который возвращает целочисленный идентификатор команды.</p>
<blockquote>
<p>Все xml-файлы в андроиде компилируются, что позволяет использовать класс <code>R</code> для хранения уникальных целочисленных идентификаторов команд.</p>
</blockquote>
<h3>Генерация ответа</h3>
<p>Агент обязан вернуть хотя бы один ответ на каждый запрос пользователя. Для этого необходимо создать контент ответа и добавить его в запрос методами <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html#addResponse(mobi.voiceassistant.base.Response)"><code>addResponse</code></a> или <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html#addQuickResponse(java.lang.Object)"><code>addQuickResponse</code></a>.</p>
<blockquote>
<p>Ассистент ведёт историю запросов пользователя. Поэтому каждый ответ нужно связывать с запросом, что и обуславливает использование методов класса <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html"><code>Request</code></a> для генерации ответа пользователю.</p>
</blockquote>
<p>Сейчас мы создадим простейший ответ, в котором пока просто поздороваемся. Это будет обычная строка текста со словом &quot;Привет&quot;. Её лучше всего записать в ресурсном файле <code>values/strings.xml</code>.</p>
<pre><code>&lt;resources&gt;
    &lt;string name=&quot;hello_hello&quot;&gt;Привет&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<p>Тогда метод <code>onHello</code> можно реализовать следующим образом</p>
<pre><code>private void onHello(Request request) {
    request.addQuickResponse(getString(R.string.hello_hello));
}
</code></pre>

<p>Здесь мы используем метод <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Request.html#addQuickResponse(java.lang.Object)"><code>addQuickResponse</code></a> для формирования быстрого ответа, передавая в качестве контента простую строку текста. Этот текст будет отображён в интерфейсе ассистента в виде &quot;<a href="bubbles.html">бабла</a>&quot; с текстом, и ассистент проговорит этот текст, если у пользователя включён TTS.</p>
<h3>Регистрация агента и запуск приложения</h3>
<p>Для того, чтобы ассистент смог обнаружить агента и загрузить его основной модуль, необходимо описать его в манифесте вашего приложения AndroidManifest.xml</p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.quickstart&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot;&gt;

    &lt;uses-sdk android:minSdkVersion=&quot;9&quot; android:targetSdkVersion=&quot;18&quot; /&gt;

    &lt;application android:label=&quot;@string/app_name&quot;
        android:icon=&quot;@drawable/ic_launcher&quot;&gt;

        &lt;service android:name=&quot;.HelloAgent&quot;&gt;

            &lt;intent-filter&gt;
                &lt;action android:name=&quot;mobi.voiceassistant.intent.action.COMMAND&quot;/&gt;
                &lt;data android:scheme=&quot;assist&quot; android:host=&quot;mobi.voiceassistant.ru&quot;/&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data android:name=&quot;mobi.voiceassistant.MODULE&quot; android:resource=&quot;@xml/hello&quot;/&gt;

        &lt;/service&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>

<p>Как видим, агент является обыкновенным сервисом. В метаданном <code>mobi.voiceassistant.MODULE</code> указывается основной модуль, который будет загружен ассистентом автоматически. Также необходимо описать action <code>mobi.voiceassistant.intent.action.COMMAND</code> в фильтре агента, указав в тэге <code>data</code> с каким из приложений &quot;Ассистента на русском&quot; работает ваш агент. В данном случае это русская версия ассистента (пакет <code>mobi.voiceassistant.ru</code>). Подробнее про регистрацию агента читайте в <a href="agents.html">специальном разделе</a>.</p>
<p>Теперь наше приложение можно собрать стандартными методами сборки Android-приложений и запустить на устройстве, где уже установлен &quot;Ассистент на русском&quot;.</p>
<p>При запуске &quot;Ассистент на русском&quot; обнаружит на устройстве наше приложение и загрузит его основной модуль. После чего все подходящие фразы будут диспетчеризоваться к нашему агенту <code>HelloAgent</code> и пользователь будет видеть в ответ бабл с текстом &quot;Привет&quot;.</p>
<blockquote>
<p>Как вы видите, наше тестовое приложение не содержит ни одной активности и не отображается в меню. Это не значит, что вы не можете использовать активности. Просто в нашем случае в этом нет необходимости.</p>
</blockquote>
<p>После первого запроса вы можете подключиться стандартным дебагером к процессу вашего приложения.</p>
<h2>Управление диалогом</h2>
<p>Сейчас мы реализуем более сложную логику, в которой будем переключать контекст диалога, сохранять имя пользователя и здороваться с ним по имени.</p>
<p>Когда пользователь говорит &quot;Привет&quot;, а наше приложение ещё не знает его имени, необходимо попросить пользователя представиться. Всё что пользователь скажет в ответ на этот вопрос будет интерпретироваться как имя. После получения имени приложение сможет сохранить его в какое-либо хранилище данных (в нашем случае мы будем использовать SharedPreferences).</p>
<h3>Модальный режим</h3>
<p>Для реализации такого сценария нам понадобится управлять диалогом, а именно входить в модальный режим. Подробнее о режимах диалога и их использовании читайте в <a href="scopes.html">специальном разделе</a>. Пока что нам достаточно знать, что модальный режим позволяет ограничить набор доступных пользователю команд, как бы скрыв все остальные команды на время. Это нужно для того, чтобы перехватить нашим агентом любую строку и интерпретировать её как имя пользователя (потому что именя бывают разные и описать все имена в паттерне не представляется возможным).</p>
<p>Создайте ещё один xml-файл в директории xml вашего приложения с именем <code>name.xml</code> с таким содержимым</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;module xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;pattern name=&quot;UserName&quot; value=&quot;*&quot;/&gt;

    &lt;command android:id=&quot;@+id/cmd_name&quot;&gt;
        &lt;pattern value=&quot;[меня зовут] $UserName&quot;/&gt;
    &lt;/command&gt;

&lt;/module&gt;
</code></pre>

<p>Здесь мы описали простой паттерн <code>UserName</code>, который &quot;поймает&quot; любую строку любой длины, и одну команду с паттерном фразы, которая <em>может</em> начинаться со слов &quot;Меня зовут&quot; и заканчиваться именем пользователя.</p>
<blockquote>
<p>Квадратные скобки обозначают, что слова &quot;Меня зовут&quot; являются необязательными - т.е. могут отсутствовать в тексте. Другими ловами, пользователь может сразу сказать своё имя. И тогда паттерн тоже сработает.</p>
</blockquote>
<p>Теперь в агенте <code>HelloAgent</code> мы можем переключить контекст беседы в модальный режим с одним этим модулем, когда захотим узнать имя. Пользователь будет вынужден сказать своё имя, если не использует слово &quot;Отмена&quot; для того чтобы не отвечать на этот вопрос.</p>
<pre><code>private void onHello(Request request) {
    final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
    final String userName = preferences.getString(PREF_NAME, null);

    if(userName == null) {
        final Response response = request.createResponse();
        response.setContent(getString(R.string.hello_say_name));
        response.enterModalQuestionScope(R.xml.name);
        request.addResponse(response);
    } else {
        request.addQuickResponse(getString(R.string.hello_hello, userName));
    }
}
</code></pre>

<p>Теперь при приветствии мы сперва заглядываем в SharedPreferences и пытаемся получить оттуда рагее сохранённое имя пользователя. Если мы его находим, то просто здороваемся с 
пользователем по имени. А если нет - то переводим диалог в модальный режим и задаём пользователю вопрос.</p>
<p>Файл <code>values/strings.xml</code> будет выглядеть следующим образом</p>
<pre><code>&lt;resources&gt;
    &lt;string name=&quot;app_name&quot;&gt;AssistantQuickStart&lt;/string&gt;
    &lt;string name=&quot;hello_hello&quot;&gt;Привет, %1$s!&lt;/string&gt;
    &lt;string name=&quot;hello_say_name&quot;&gt;Привет. А как тебя зовут?&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<blockquote>
<p>Метод <code>enterModalQuestionScope</code> не просто заставит ассистента перейти в модальный режим, но ещё и автоматически включит микрофон после того, как ассистент озвучит текст вопроса.</p>
</blockquote>
<p>Пользователь теперь должен либо назвать своё имя, либо сказать &quot;Отмена&quot; для выхода из модального режима. Иначе любая его фраза будет восприниматься нашим агентом как имя, т.к. сработает команда с идентификатором <code>cmd_name</code>.</p>
<h3>Обработка запроса в модальном режиме</h3>
<p>Ответ в модальном режиме почти ничем не отличается от ответа в обчном за исключением того, что пользователь может выйти из него с помощью команды &quot;Отмена&quot; или ответить что-то, что не может быть обработано паттернами указанного модуля. Если второй вариант нас не беспокоит в данном случае (т.к. любая фраза будет интерпретирована как имя), то на отмену нужно как-то прореагировать.</p>
<p>Для этого агент должен переопределить метод <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Agent.html#onModalCancel(mobi.voiceassistant.base.Request)"><code>onModalCancel</code></a>, в котором нужно тоже вернуть какой-либо контент для адекватного ответа пользователю. В нашем случае мы вернём простую строку с текстом &quot;Пока&quot;</p>
<pre><code>@Override
protected void onModalCancel(Request request) {
    request.addQuickResponse(getString(R.string.hello_cancel));
}
</code></pre>

<p>В случае же нормального пользовательского ответа мы получим обычную команду, которую сможем обработать в методе <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Agent.html#onCommand(mobi.voiceassistant.base.Request)"><code>onCommand</code></a></p>
<pre><code>@Override
protected void onCommand(Request request) {
    switch (request.getDispatchId()) {
        case R.id.cmd_hello:
            onHello(request);
            break;
        case R.id.cmd_name:
            onName(request);
            break;
    }
}

private void onName(Request request) {
}
</code></pre>

<p>В методе <code>onName</code> мы сможем получить из запроса имя и сохранить в SharedPreferences, после чего поздороваться с пользователем по этому имени</p>
<pre><code>private void onName(Request request) {
    final Token token = request.getContent();
    final Token nameToken = token.findTokenByName(TOKEN_NAME);
    final String userName = nameToken.getSource();

    if(userName.length() == 0) {
        final Response response = request.createResponse();
        response.setContent(getString(R.string.hello_say_again));
        response.enterModalQuestionScope(R.xml.name);
        request.addResponse(response);
        return;
    }

    final StringBuilder sb = new StringBuilder(userName);
    sb.setCharAt(0, Character.toUpperCase(userName.charAt(0)));
    final String displayName = sb.toString();

    final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
    preferences.edit().putString(PREF_NAME, displayName).commit();

    onHello(request);
}
</code></pre>

<p>В данном случае мы имеем дело с речевым взаимодействием с пользователем, поэтому контентом запроса будет являться <a href="token.html">токен</a> - семантическое дерево разбора фразы. Этот токен содержит дочерний токен с именем UserName, который мы можем получить с помощью метода <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Token.html#findTokenByName(java.lang.String)"><code>findTokenByName</code></a>.</p>
<p>Токен UserName содержит простой текст в поле <code>source</code>, который мы можем интерпретировать как имя. Т.к. мы определили паттерн UserName как <code>*</code>, то это значит, что строка текста может быть и нулевой длины (например, если пользователь скажет только начало фразы &quot;Меня зовут&quot;). Для обработки этого случая мы проверяем длину строки токена и снова переводим ассистента в модальный режим с просьбой повторить имя если строка оказалась пустой.</p>
<p>Если же пользователь сказал имя, то мы можем сохранить его в SharedPreferences и сгенерировать ответ.</p>
<blockquote>
<p>Важно запомнить, что ассистент не переходит снова в модальный режим после отработки команды или метода <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/Agent.html#onModalFail(mobi.voiceassistant.base.Request)"><code>onMoalFail</code></a>.</p>
</blockquote>
<p>Файл <code>values/strings.xml</code> будет содержать следующие строки</p>
<pre><code>&lt;resources&gt;
    &lt;string name=&quot;app_name&quot;&gt;AssistantQuickStart&lt;/string&gt;
    &lt;string name=&quot;hello_hello&quot;&gt;Привет, %1$s!&lt;/string&gt;
    &lt;string name=&quot;hello_say_name&quot;&gt;Привет. А как тебя зовут?&lt;/string&gt;
    &lt;string name=&quot;hello_say_again&quot;&gt;Прости, не понимаю. Как тебя зовут?&lt;/string&gt;
    &lt;string name=&quot;hello_cancel&quot;&gt;Пока&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<p>Теперь можно снова собрать приложение и установить его на девайсе. После этого &quot;Ассистент на русском&quot; перезагрузит модуль и им можно будет сразу пользоваться.</p>
<h2>Нестандартная озвучка ответа</h2>
<p>Как вы можете заметить, TTS ассистента пытается использовать интонацию, подходящую для того текста, который мы вернули в ответе. Но не всегда эта интонация подходит в конкретном случае. Например, в нашем приложении синтаксически верно отделить слово &quot;Привет&quot; от имени пользователя запятой. Но при произношении приветствия в реальной жизни мы не ставим паузу между &quot;Привет&quot; и именем. </p>
<p>Поэтому нужно описать другую (более правльную) озвучку для приветствия, в которой не будет паузы. Для этого запишем в файле <code>values/strings.xml</code> ещё одну строку для озвучки</p>
<pre><code>&lt;string name=&quot;speech_hello&quot;&gt;привет %1$s&lt;/string&gt;
</code></pre>

<p>В ней мы убрали запятую между словами. Эта строчка будет озвучиваться ассистентом более правильно.</p>
<p>Для использования такого произношения нам понадобится использовать утилитный класс API <a href="http://voiceassistant.mobi/reference/mobi/voiceassistant/base/content/SpeechTextUtils.html"><code>SpeechTextUtils</code></a></p>
<pre><code>private void onHello(Request request) {
    final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
    final String userName = preferences.getString(PREF_NAME, null);

    if(userName == null) {
        final Response response = request.createResponse();
        response.setContent(getString(R.string.hello_say_name));
        response.enterModalQuestionScope(R.xml.name);
        request.addResponse(response);
    } else {
        final CharSequence content = SpeechTextUtils.textWithSpeech(getString(R.string.hello_hello, userName), getString(R.string.speech_hello, userName));
        request.addQuickResponse(content);
    }
}
</code></pre>

<p>Здесь мы генерируем ответ в виде <a href="http://developer.android.com/reference/java/lang/CharSequence.html">CharSequence</a>, в котором текст для бабла и текст для озвучки различны.</p>
<h2>Как поменять своё имя</h2>
<p>Т.к. наше приложение хранит имя пользователя в <a href="http://developer.android.com/reference/android/content/SharedPreferences.html">SharedPreferences</a>, то для смены имени можно просто очистить данные приложения через менеджер приложений. Но это нам не оченб подходит, и мы попробуем изменить грамматику нашего модуля так, чтобы пользователь в любой момент мог представиться ассистенту заново. Для этого можно изменить основной модуль hello.xml следующим образом</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;module xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;pattern name=&quot;UserName&quot; value=&quot;*&quot; /&gt;

    &lt;command android:id=&quot;@+id/cmd_hello&quot;&gt;
        &lt;pattern value=&quot;привет* *&quot;/&gt;
    &lt;/command&gt;

    &lt;command android:id=&quot;@+id/cmd_name&quot;&gt;
        &lt;pattern value=&quot;* меня зовут $UserName&quot;/&gt;
    &lt;/command&gt;

&lt;/module&gt;
</code></pre>

<p>Здесь мы всего лишь добавили команду <code>cmd_name</code> и паттерн <code>UserName</code> в наш основной модуль, после чего агент сможет обрабатывать фразу типа &quot;Привет меня зовут Пётр&quot; без входа в модальный режим и дополнительного вопроса. Агент просто перезапишет ранее сохранённое имя и поздоровается. Код менять не нужно.</p>
<blockquote>
<p>Как вы заметили, паттерн команды в основном модуле отличается от той же команды в модуле name.xml. В новом паттерне слова &quot;Меня зовут&quot; стали обязательными, т.к. без этого ваш агент реагировал бы на любую фразу, которая не подошла ни под один из паттернов других агентов.</p>
</blockquote>
<h2>В заключение</h2>
<p>В этом примере мы реализовали простое приложение, которое подключается к ассистенту и устанавливает речевой контакт с пользователем. Мы научились менять контекст диалога, генерировать ответы (в том числе с различной озвучкой) и получать данные из речи пользователя.</p>
<p>Как видно из примера, приложение ничем не отличается от стандартного приложения под Android. В нём могут использоваться активности, сервисы, можно управлять сохранением данных и вообще проделывать все те операции, которые доступны любому Android-приложению.</p>
<blockquote>
<p>В данном примере мы использовали самый простой вид коммуникации с пользователем и самый простой GUI для отображения данных. Для создания гораздо более сложного GUI изучите раздел <a href="bubbles.html">бабблы</a>.</p>
</blockquote>
<p>Далее мы предлагаем вам изучить тему <a href="architecture.html">&quot;Архитектура&quot;</a>, которая детально описывает каждый компонент ассистента и способы коммуникации с пользователем. Понимание этих аспектов позволит реализовать гораздо более сложные голосовые приложения из реальной жизни.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
