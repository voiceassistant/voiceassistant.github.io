<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>architecture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Архитектура API <em>Ассистента на русском</em></h1>
<p>Приложение <em>&quot;Ассистент на русском&quot;</em> - это стандартное приложение под ОС Android, взаимодействующее с пользователем как с помощью речи, так и посредством графического интерфейса (GUI). Ассистент содержит набор собственных сервисов, которые так же реализованы с помощью данного API - мы называем их билтинами (built-in). APi предоставляет реализовать свои собственные (сторониие) сервисы, которые можно называть плагинами (plugins).</p>
<h2>Что такое сервис</h2>
<p>Каждый сервис - это набор из <a href="agents.html">агентов</a>, <a href="grammarsyntax.html">модулей</a> и некоторой бизнес-логики. Агенты представляют собой надстройку над <a href="http://developer.android.com/guide/components/services.html">Android-сервисами</a>, а взаимодействие между ассистентом и агентом происходит за счёт межпроцессной коммуникации (IPC).</p>
<h2>Функции ассистента</h2>
<p>Само приложение <em>&quot;Ассистент на русском&quot;</em> состоит из GUI и ядра, в функции которого входит диспетчеризация запросов от пользователя к нужному агенту и получение от агента результата (ов) для отображения пользователю и переключение диалогового контекста. Компонент, выполняющий эти операции (не зависящие от GUI) называется <code>Dispatcher</code>.</p>
<blockquote>
<p>Таким образом, ассистент - это полностью модульная структура, разделяющая уровень представления (GUI), логику управления диалогом (Dispatcher) и сервисы (<a href="agents.html">Агенты</a>).</p>
</blockquote>
<h2>Распознавание речи и NLP</h2>
<p>Ассистент взаимодействует с системой распознавания речи (ASR), позволяющей получить из пользовательской речи строку, которая затем обрабатывается специальным компонентом ядра - <em>Матчером</em>. Матчер реализует функцию NLP (процессинг натуральной речи), используя данные <a href="grammarsyntax.html">модулей</a>, описывающих <a href="patternsyntax.html">паттерны</a> пользовательских речевых запросов. Результатом работы матчера является решение о том, какую команду какого агента из текущего <a href="scopes.html">скоупа</a> и с какими параметрами (<a href="token.html">дерево разбора текста</a>) необходимо выполнить.</p>
<p><em>Скоупами называются наборы модулей, доступных в данный момент времени пользователю. Такие наборы формируют диалоговый контекст.</em></p>
<blockquote>
<p><em>Ассистент на русском</em> использует сторонние решения ASR и полностью независим от конкретной реализации данной технологии.</p>
</blockquote>
<h3>Гибридный NLP</h3>
<p>Матчер в &quot;Ассистенте на русском&quot; реализует гибридное NLP, при котором для матчинга текста по паттернам используются данные из разных источников. Другими словами, матчер перед процессингом текста может получить данные из локальЫных БД или отправить строку на удалённые сервера, где хранятся большие объёмы данных. Эти сервера дополняют информацию о тексте (производят <em>аннотирование</em>) и возвращают эту информацию для процессинга локальному матчеру. Таким образом можно хранить некоторые данные на серверах (например, списки городов мира), а некоторые локально на устройстве (список контактов или названия приложений).</p>
<p>Таким образом, вы можете сформировать паттерны различными способами, что позволяет реализовать сколь угодно сложный вид речевой коммуникации с пользователем:</p>
<ul>
<li>Статически описать их в <a href="modules.html">модуле</a></li>
<li>Использовать <a href="contentproviders.html">контент-провайдеры</a> для динамической генерации сущностей для паттерна (в том числе и для получения данных с удаленных устройств или из локальных БД)</li>
<li>Хранить большие списки сущностей на серверах, где работает специальный аннотатор, а в паттерне указать источник (атрибут <code>uri</code>)</li>
</ul>
<blockquote>
<p>О том, как использовать аннотирование текста на удалённых серверах, читайте в разделе <a href="contentproviders.html">контент-провайдеры</a>.</p>
</blockquote>
<p>Это позволяет масштабировать разрабатываемую систему так, что становится возможным, с одной стороны, не зависеть от способов хранения необходимых данных, а с другой - не описывать все возможные сущности, а ограничиться только теми, которые действительно необходимы для реализации логики приложения.</p>
<h2>Взаимодействие с агентом</h2>
<p>Как было сказано выше, ядро ассистента взаимодействует с <a href="agents.html">агентом</a> с помощью IPC. Агент, по сути, выполняет роль программного интерфейса между ассистентом и бизнес-логикой приложения. Каждый агент описывается в манифесте приложения <code>AndroidManifest.xml</code>, и ассистент загружает его основной модуль каждый раз при &quot;холодном&quot; старте или динамически при установке приложения.</p>
<p>Далее при каждом запросе пользователя к агенту ассистент вызывает методы абстрактного класса <code>AssistantAgent</code>, которые должны быть реализованы конкретным агентом. Ассистент ведёт историю запросов пользователя и привязывает ответ(ы) от агента на запрос к конкретному элементу в истории.</p>
<p>Каждый ответ от агента - это некоторый контент, отображаемый в GUI ассистента и, опционально, инструкция по управлению диалогом (подробнее в разделе <a href="scopes.html">Scopes</a>).</p>
<blockquote>
<p>Подробнее о видах контента, генерируемого агентами, читайте в разделе <a href="bubbles.html">баблы</a>.</p>
</blockquote>
<h2>Схема взаимодействия пользователя с агентами</h2>
<p><img src="img/architecture.png" /></p>
<p><em>Синим в этой схеме обозначаются компоненты, реализованные в Ассистенте. Розовым - компоненты, которые необходимо реализовать разработчику в своем приложении. Зеленым - сторонние компоненты</em></p>
<p>В общем случае, после успешной загрузки модулей вашего приложения ассистентом, схема взаимодействия пользователя с агентом выглядит так:</p>
<ol>
<li>Пользователь взаимодействует с приложением &quot;Ассистент на русском&quot; либо с помощью речи (активирует микрофон и говорит фразу), либо с помощью touch-интерфейса (нажимает на кнопки, выбирает элементы из списка и т.п.).</li>
<li>Ассистент обрабатывает ввод пользователя и, при необходимости, взаимодействует с системой распознавания речи (ASR) для получения строки текста из речи.</li>
<li>Затем Ассистент формирует запрос (Request) к диспетчеру (Dispatcher), который управляет всем процессом взаимодействия с матчером и агентами.</li>
<li>Диспетчер в каждый момент времени хранит информацию о <a href="scopes.html">состоянии контекста</a>. Получив от Ассистента запрос, он вызывает Матчер на том скоупе, который сейчас активен, передавая Матчеру строку текста. <em>Если запрос пользователя представляет собой взаимодействие с GUI (PendingRequest), а не речь, то процесс взаимодействия с Матчером пропускается и Диспетчер напрямую диспетчеризует уже готовый запрос к Агенту (п. 7).</em></li>
<li>При наличии сетевого подключения Матчер сперва отправляет строку на удаленные сервера для добавления в текст необходимой информации, а затем производит матчинг по паттернам из указанного скоупа модулей.</li>
<li>Результатом работы Матчера является информация о том, какую команду какого агента необходимо вызывать. Также Матчер возвращает Диспетчеру <a href="token.html">токен</a> - семантическое дерево разбора фразы по паттерну команды.</li>
<li>Диспетчер формирует запрос к конкретному Агенту приложения, при необходимочти разворачивая <a href="scopes.html">автоматические скоупы</a>. Вызов методов Агента происходит по IPC.</li>
<li>Агент обрабатывает вызов одного из методов <code>AssistantAgent</code>, взаимодействуя с логикой приложения. Реализация этого взаимодействия ничем не ограничена и зависит только от разработчика приложения.</li>
<li>На каждый запрос от Диспетчера Агент обязан вернуть хотя бы один ответ (Response), который содержит <a href="bubbles.html">контент ответа</a> и, по необходимости, информацию об изменении скоупа. <em>Если выполнение логики приложения занимает продолжительное время (сетевое взаимодействие и т.п. операции), то Агент может вернуть Диспетчеру ответ, уйти в бэкграунд (<code>goBackground</code>), а затем обновить уже отправленные ранее ответ.</em></li>
<li>После получения от Агента ответа(ов), Диспетчер обновляет состояние скоупа и передает Ассистенту необходимые данные для отображения в пользовательском интерфейсе и озвучки результата через TTS.</li>
</ol>
<h2>Виды взаимодействия агента с ассистентом</h2>
<p>С точки зрения способа реализации взаимодействия агента с ядром ассистента, существует несколько подходов.</p>
<p><img src="img/agents.png" /></p>
<h3>Built-in агент</h3>
<p>Этот вид реализации агентов используется для сервисов самого &quot;Ассистента на русском&quot; или любого другого приложения, реализованного на его ядре (не описывается в данном документе).</p>
<h3>Сторонний агент</h3>
<p>Этот вид используется для реализации взаимодействия вашего (стороннего) приложения с ассистентом. Агент реализуется на стороне вашего приложения и предоставляет интерфейс к нему. Такой агент может отображать необходимый GUI внутри ассистента посредством <a href="bubbles.html">баблов</a>.</p>
<blockquote>
<p>Ваше приложение при этом не обязано иметь <em>собственный</em> touch GUI, иконку для лаунчера и т.д. В таком случае, оно будет выглядеть как plug-in к ассистенту.</p>
</blockquote>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
